% !TEX root = ../report.tex

\chapter{Software}\label{software}
The software architecture was centred on the event driven implicit implication
design pattern~\cite{garlan1993introduction}. This architecture design pattern is
also known as the ``Hollywood'' design pattern due to its definition of ``Don't
call us, we'll call you''. With regards to software architecture this means
modules are signalled to start by other modules and this is propagated through
the system with ``events'' triggering other ``events'' within the system.

To implement this architecture, each part of the system can be defined as its own
module with a function which triggers its invocation and a function which can
broadcast events if required. A methodology for implementation of this system is
the publish/subscribe model. Each modules' invoking function is a publisher and
modules which would be triggered by this function are known as subscribers. Using
this method in the context of this project, means the software has strong support
for reuse---as new sensors or libraries can be plugged in and subscribe to the
appropriate events---and loose coupling throughout the system means that
maintenance of each module can take place independently.

In robotic systems, this architecture is highly beneficial as each of the sensor
and actuator systems can run independently publishing their data for feedback,
using event driven implicit invocation through data driven programming. This
reduces the risk of system crashes as module crashes are isolated, improving
robustness.

\section{ROS}\label{soft/ROS}
In order to implement this architecture, and following extensive research(see
Section~\ref{litreview/ROS}, the Robot Operating System (ROS) library was
selected as a framework. The ROS library makes it simple to design and implement
individual modules within a system and uses a central control node named
``roscore'' to manage publish and subscribe ``topics'' between modules.

\subsection{Design}\label{soft/ROS/design}
Following the decision to use ROS to implement our chosen architecture, a modular
approach was adopted for the design of each of the components within the system~
\ref{elec}. Hence, a system block diagram was developed to visualise data flow
within the system. \todo{put in block diagram} The block diagram in Figure~
\ref{BlockDiagram} demonstrates the modularisation of the system and also the
expectation that the AI module at the top of the system will be completely
independent from the other components of the system. By making the control module
an API, AI algorithms can be interchanged easily for testing. The modular
approach also means sensor and actuator modules can be plugged in and out as
desired and could easily be changed if needed at any point in the project.

Each module can be programmed in a different language before being converted to a
ROS node, which publishes and subscribes, using the appropriate methods for that
language. Although the majority of the system will be programmed in Python,
allowing different programming languages means that timing or processing
sensitive operations can be programmed in C or C++ as required. Once converted to
a ROS node, each module can then be started individually using a ROS launch file.
Launch files are used by ROS to create and start a number of nodes within a
system with any number of parameters. Again, due to the modular approach and use
of ROS, launch files allow various configurations of modules to be tested easily.

In order for ROS launch files to function, the directory structure within the
``catkin''~\cite{catkin} workspace must be configured correctly. ``Catkin is the
CMake based build system that is used to build packages in ROS''~\cite{gitcatkin}
and requires a strict directory structure in order to build each of the
individual modules within the project. Packages within ROS allow code to be
maintained and compartmentalised, and by using packages throughout existing
packages can be added easily.

Considerations of appropriate packages were made and a final design UML diagram
created\todo{UML~\ref{UMLDiagram}}. This demonstrates a full system
implementation and the expected interactions between each of the modules within
the program.


\subsection{Implementation}\label{soft/ROS/impl}
Each of the individual modules discussed in Section~\ref{elec} was implemented as a ROS node, generally encapsulated in a single Python script. In order to adhere to best practices and ensure consitency across the code base, each node was represented as class, with an \verb|__init__()| method initialising the node and a \verb|spin()| method which is called to keep the node running. In nodes which perform recurring work, such as the sensor nodes, this method uses a \verb|rospy.Rate| object to schedule tasks, whereas nodes that respond to events on subscribed topics simply call \verb|rospy.spin()|, which prevents the script from exiting until a ROS shutdown signal is received. Listing~\ref{lst:ros_node} shows an example of a ROS nod that publishes at a predefined rate. The rate can be passed in as a parameter in the launch file, and defaults to \SI{10}{\Hz}.

\begin{lstlisting}[caption={Example ROS node}, label={lst:ros_node}]
#!/usr/bin/env python
import rospy
from std_msgs.msg import Int16


class Node:
    def __init__(self):
        rospy.init_node('node_name')
        self.rate = rospy.Rate(rospy.get_param("~rate", 10))
        self.pub = rospy.Publisher('topic', Int16, queue_size=10)
        self.data = 0

    def spin(self):
        try:
            while not rospy.is_shutdown():
                self.pub.publish(self.data)
                self.rate.sleep()
        finally:
            self._cleanup()

    def _cleanup(self):
        # Perform cleanup operations such as saving data to files
        # or clearing GPIO setup


if __name__ == '__main__':
    try:
        node = Node()
        node.spin()
    except rospy.ROSInterruptException:
        pass
\end{lstlisting}

This listing shows the Python
version of a ROS node, which is the case for the majority of the nodes. Although
a variety of languages was permissible, in practice the majority of the code base
is Python. The \verb|spin()| method is the ``main loop'' for each of the modules and
carries out tasks while the node is running. Each of the nodes which publish
information to the system also use the \verb|rospy.Publisher| class to create objects
which can then publish messages of a pre-determined type to the system.
Similarly, \verb|rospy.Subscriber| is used by nodes wishing to listen for messages on
a specific topic.

To further modularise the code for each node, object oriented Python was used and
each node defined as its own class. This meant that each method within the class
was defined for that class and function names could be repeated throughout the
codebase where this made sense, such as with the \verb|spin()| method. Each node also
has an \verb|init()| method which is called on instantiation of the class which it
is contained within. This \todo{add init listing} example code shows the setup
for the Motor node. A number of parameters are set or drawn in from the launch
file from which the node was created and the node set as a subscriber to the
\verb|motor cmd| topic which gives instructions to the Motor node. By using a number of parameters the code maintains its flexibility as these can be tuned in different launch files to different values. Topic values can also be changed on the fly using thje command line from within a catkin workspace, allowing real time tuning of parameters to take place.
  \todo{David needs to write this i think}


\subsection{Testing}\label{soft/ROS/test}
In addition to each of the nodes being tested independently in a similar manner to how each of them were tested in isolation throughout the~\ref{elec} Section, the nodes were tested in a number of different configurations.
\todo{David maybe needs to write this}

Each of the topics can be tracked from the main graph of nodes in the ROS runtime using the command $rqt graph$. This produces the following output, \todo{put rqt grpah of nodes and topics in here and dicuss}.


\subsection{Deployment}\label{soft/ROS/deploy}
Since system testing was closely tied to the hardware of the robot, the ability to rapidly deploy changes to the robot was crucial to the development process. To this end, a shell script (\verb|deploy.sh|) was written to copy any changes to robots connected to the network. The script uses \verb|rsync| to copy any modified source or configuration files in the Catkin workspace, and fetches any output files generated by previous executions of the code. Since the Raspberry Pis are unable to retain system time between boot cycles, and \verb|rsync| relies on system time to detect file modifications, the script additionally syncs the system time of the Pi to the host machine. The system time is set using UTC in order to prevent problems caused by time zones and daylight saving time.

The installation of software dependencies proved to be less trivial due to difficulties connecting to the internet and WANET simultaneously. Dependencies were initially installed manually on a single Pi connected to the internet, and were then transferred to the other robots by copying an image of the SD card. This method had the additional benefit of ensuring that all Pis were running the same versions of any dependencies.


\section{Communication}\label{soft/comms}

\subsection{Design}\label{soft/comms/design}

\subsection{Implementation}\label{soft/comms/impl}

\subsection{Testing}\label{soft/comms/test}




\section{SLAM \& Sensor Fusion}\label{soft/SLAM}

\subsection{Design}\label{soft/SLAM/design}

\subsection{Implementation}\label{soft/SLAM/impl}

\subsection{Testing}\label{soft/SLAM/test}



\section{Computer Vision}\label{soft/cv}

\subsection{Design}\label{soft/cv/design}

\subsection{Implementation}\label{soft/cv/impl}

\subsection{Testing}\label{soft/cv/test}



\section{AI \& Control Modules}\label{soft/ai}

\subsection{Design}\label{soft/ai/design}

\subsection{Implementation}\label{soft/ai/impl}

\subsection{Testing}\label{soft/ai/test}
